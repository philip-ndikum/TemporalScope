""" TemporalScope/src/temporalscope/core/temporal_target_shifter.py

This module provides a transformer-like class to shift the target variable in time series data, either
to a scalar value (for classical machine learning) or to an array (for deep learning).
It is designed to work with the TimeFrame class, supporting multiple backends.

.. seealso::

    1. Torres, J.F., Hadjout, D., Sebaa, A., Martínez-Álvarez, F., & Troncoso, A. (2021). Deep learning for time series forecasting: a survey. Big Data, 9(1), 3-21. https://doi.org/10.1089/big.2020.0159
    2. Lim, B., & Zohren, S. (2021). Time-series forecasting with deep learning: a survey. Philosophical Transactions of the Royal Society A, 379(2194), 20200209. https://doi.org/10.1098/rsta.2020.0209
    3. Tang, Y., Song, Z., Zhu, Y., Yuan, H., Hou, M., Ji, J., Tang, C., & Li, J. (2022). A survey on machine learning models for financial time series forecasting. Neurocomputing, 512, 363-380. https://doi.org/10.1016/j.neucom.2022.09.078

TemporalScope is Licensed under the Apache License, Version 2.0 (the "License");
you may not use this file except in compliance with the License.
You may obtain a copy of the License at

    http://www.apache.org/licenses/LICENSE-2.0

Unless required by applicable law or agreed to in writing, software
distributed under the License is distributed on an "AS IS" BASIS,
WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
See the License for the specific language governing permissions and
limitations under the License.
"""

from typing import Union, Optional, Any, SupportsIndex
import polars as pl
import pandas as pd
import modin.pandas as mpd
import numpy as np
from temporalscope.conf import validate_backend, validate_input
from temporalscope.core.temporal_data_loader import TimeFrame


class TemporalTargetShifter:
    """A class for shifting the target variable in time series data for machine learning or deep learning.

    This class works with the `TimeFrame` class to shift the target variable by a specified
    number of lags (time steps). It supports multiple backends (Polars, Pandas, Modin) and can
    generate output suitable for both machine learning models (scalar) and deep learning models (sequence).

    The class is designed to handle both raw `TimeFrame` data and data that has been partitioned
    using a partitioner, such as `SlidingWindowPartitioner`.

    Assumptions:
    ------------
    1. The data is not grouped by any categorical variables.
    2. The `time_col` contains unique time points, ensuring predictable and unambiguous shifting.

    :param n_lags: Number of lags (time steps) to shift the target variable. Default is 1.
    :type n_lags: int
    :param mode: Mode of operation: "machine_learning" for scalar or "deep_learning" for sequences.
                 Default is "machine_learning".
    :type mode: str
    :param sequence_length: (Deep Learning Mode Only) The length of the input sequences. Required if mode is "deep_learning".
    :type sequence_length: Optional[int]
    :raises ValueError: If the backend is unsupported or if validation checks fail.

    .. note::
       For deep learning frameworks like TensorFlow, PyTorch, and JAX/Flax, the expected shape of the target
       in "deep_learning" mode generated by this class is `(num_sequences, sequence_length)`.
       Batching is typically handled by the data loader or model input pipeline.

    Example Usage:
    --------------
    .. code-block:: python

       # Example of creating a TimeFrame with a Polars DataFrame
       data = pl.DataFrame({
           'time': pl.date_range(start='2021-01-01', periods=100, interval='1d'),
           'value': range(100)
       })
       tf = TimeFrame(data, time_col='time', target_col='value')

       # Using TemporalTargetShifter in machine_learning mode
       shifter_ml = TemporalTargetShifter(n_lags=3, mode='machine_learning')
       tf_transformed_ml = shifter_ml.fit_transform(tf)

       # Accessing the shifted data
       print("Machine Learning Mode (Scalar):")
       print(tf_transformed_ml.get_data().head())

       # Using TemporalTargetShifter in deep_learning mode
       shifter_dl = TemporalTargetShifter(n_lags=3, mode='deep_learning', sequence_length=10)
       tf_transformed_dl = shifter_dl.fit_transform(tf)

       # Accessing the shifted data for deep learning
       print("Deep Learning Mode (Sequence):")
       print(tf_transformed_dl.get_data().head())

       # Example: Create a TimeFrame with a Modin DataFrame
       import modin.pandas as mpd
       df = mpd.DataFrame({
           'time': pd.date_range(start='2021-01-01', periods=100, freq='D'),
           'value': range(100)
       })
       tf_modin = TimeFrame(df, time_col='time', target_col='value', backend='mpd')

       # Accessing the data
       print("Original Modin DataFrame:")
       print(tf_modin.get_data().head())
    """

    def __init__(
        self,
        n_lags: int = 1,
        mode: str = "machine_learning",
        sequence_length: Optional[int] = None,
    ):
        if mode not in ["machine_learning", "deep_learning"]:
            raise ValueError("`mode` must be 'machine_learning' or 'deep_learning'.")

        self.n_lags = n_lags
        self.mode = mode
        self.sequence_length = sequence_length

        if self.mode == "deep_learning" and not self.sequence_length:
            raise ValueError(
                "`sequence_length` must be provided when mode is 'deep_learning'."
            )

    def fit(self, tf: TimeFrame) -> "TemporalTargetShifter":
        """Validates the input TimeFrame without altering it.

        :param tf: The TimeFrame object to validate.
        :type tf: TimeFrame
        :rtype: TemporalTargetShifter
        :raises ValueError: If data validation fails.
        """
        self._validate_data(tf)
        self.backend = tf.backend  # Store the backend for later use
        return self

    def transform(self, tf: TimeFrame) -> TimeFrame:
        """Shift the target variable according to the number of lags specified.

        This method can operate on both raw TimeFrame data and partitioned data.

        :param tf: The TimeFrame object to transform.
        :type tf: TimeFrame
        :rtype: TimeFrame
        :raises ValueError: If the backend is unsupported or data validation fails.
        """
        df = tf.get_data()
        target_col = tf._target_col

        if self.backend == "pl":
            df = self._shift_polars(df, target_col)
        elif self.backend in ["pd", "mpd"]:
            df = self._shift_pandas_modin(df, target_col)
        else:
            raise ValueError(f"Unsupported backend: {self.backend}")

        tf.update_data(df)
        return tf

    def fit_transform(self, tf: TimeFrame) -> TimeFrame:
        """Combine fit and transform into a single call.

        :param tf: The TimeFrame object to transform.
        :type tf: TimeFrame
        :rtype: TimeFrame
        """
        return self.fit(tf).transform(tf)

    def _validate_data(self, tf: TimeFrame) -> None:
        """Validate the TimeFrame data for consistency."""
        df = tf.get_data()
        time_col = tf._time_col

        validate_backend(tf.backend)
        validate_input(df, tf.backend)

        # Ensure df[time_col] is treated as a Series, to avoid Mypy errors
        if isinstance(df, pl.DataFrame):
            if df[time_col].is_duplicated().any():
                raise ValueError(
                    "The time column contains duplicate values, which is not allowed."
                )
        elif isinstance(df, (pd.DataFrame, mpd.DataFrame)):
            if df[time_col].duplicated().any():
                raise ValueError(
                    "The time column contains duplicate values, which is not allowed."
                )

    def _shift_polars(self, df: pl.DataFrame, target_col: str) -> pl.DataFrame:
        """Shift the target variable in a Polars DataFrame.

        :param df: The Polars DataFrame containing the time series data.
        :type df: pl.DataFrame
        :param target_col: The column representing the target variable.
        :type target_col: str
        :return: The Polars DataFrame with the shifted target variable.
        :rtype: pl.DataFrame
        :raises ValueError: If the backend is unsupported or data validation fails.
        """
        if self.mode == "deep_learning":
            if self.sequence_length is None:
                raise ValueError(
                    "`sequence_length` must be provided in deep_learning mode."
                )

            shifted_columns = [
                df[target_col].shift(-i).alias(f"{target_col}_shift_{i}")
                for i in range(self.sequence_length)
            ]
            df = df.with_columns(shifted_columns)
            df = df.with_columns(
                [
                    pl.concat_list(
                        [
                            pl.col(f"{target_col}_shift_{i}")
                            for i in range(self.sequence_length)
                        ]
                    ).alias(f"{target_col}_sequence")
                ]
            )
            df = df.drop(
                [f"{target_col}_shift_{i}" for i in range(self.sequence_length)]
            )
        else:  # Machine Learning Mode (Scalar)
            df = df.with_columns(
                [
                    df[target_col]
                    .shift(-self.n_lags)
                    .alias(f"{target_col}_shift_{self.n_lags}")
                ]
            )

        return df.drop_nulls()

    def _shift_pandas_modin(
        self, df: Union[pd.DataFrame, mpd.DataFrame], target_col: str
    ) -> Union[pd.DataFrame, mpd.DataFrame]:
        """Shift the target variable in a Pandas or Modin DataFrame.

        :param df: The Pandas or Modin DataFrame containing the time series data.
        :type df: Union[pd.DataFrame, mpd.DataFrame]
        :param target_col: The column representing the target variable.
        :type target_col: str
        :return: The DataFrame with the shifted target variable.
        :rtype: Union[pd.DataFrame, mpd.DataFrame]
        :raises ValueError: If the backend is unsupported or data validation fails.
        """
        if self.mode == "deep_learning":
            if self.sequence_length is None:
                raise ValueError(
                    "`sequence_length` must be an integer when mode is 'deep_learning'."
                )

            shifted_columns = [
                df[target_col].shift(-i) for i in range(self.sequence_length)
            ]
            df[f"{target_col}_sequence"] = np.stack(shifted_columns, axis=1).tolist()
        else:  # Machine Learning Mode (Scalar)
            df[f"{target_col}_shift_{self.n_lags}"] = df[target_col].shift(-self.n_lags)

        return df.dropna()
